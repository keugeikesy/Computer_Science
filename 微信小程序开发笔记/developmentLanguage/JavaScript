|
|------+
|      |
|      基本语法
|            |
|            |------+
|            |      |
|            |      多行注释符：/* */
|            |
|            |------+
|            |      |
|            |      单行注释符：//
|            |
|            |------+
|            |      |
|            |      Js严格区分大小写
|            |
|            |------+
|            |      |
|            |      JS中多个空格和换行会被忽略
|            |
|            |------+
|                   |
|                   Js中每条语句都应该以分号结尾,分号表示该语句的结束
|
|------+
|      |
|      Js中的数值
|           |
|           |------+
|           |      |
|           |      字面量：是一个值，可以直接使用
|           |
|           |------+
|           |      |
|           |      变量：可以存储字面量，也可以对变量中存储的值进行修改
|           |           |
|           |           |------+
|           |                  |
|           |                  1.声明变量 --- 2.给变量赋值
|           |
|           |------+
|                  |
|                  常量：不可变的变量
|                       |
|                       |------+
|                              |
|                              const 变量名 = 值    
|------+    
|      |
|      标识符
|           |
|           |------+
|           |      |
|           |      定义：用于标记变量、函数等由编写者自定义的名称称之为标识符
|           |
|           |------+
|                  |
|                  命名方式：驼峰命名法——首字母小写，其他每个单词开头大写
|------+
|      |
|      数据类型
|           |
|           |------+
|           |      |
|           |      分  类
|           |           |
|           |           |------+
|           |           |      |
|           |           |      可变类型：创建后,不可以对其进行修改
|           |           |
|           |           |------+
|           |                  |
|           |                  不可变类型：创建后,可以任意的添加、删除、修改其属性
|           |------+
|           |      |
|           |      类型检查：typeof 变量名(返回变量中值的类型)
|           |
|           |------+
|           |      |
|           |      原始值(不可变类型)：只能用来表示一些简单的数据,不能表示复杂数据
|           |           |
|           |           |------+
|           |           |      |
|           |           |      数值：所有整数与浮点数                          类型：Number类型
|           |           |
|           |           |------+
|           |           |      |
|           |           |      大整数：用来表示一些比较大的整数(数字以n结尾)     类型：BigInt
|           |           |
|           |           |------+
|           |           |      |
|           |           |      字符串：使用单引号或双引号来表示字符串            类型：String
|           |           |
|           |           |------+
|           |           |      |
|           |           |      布尔值：用来进行逻辑判断---true false            类型：Boolean
|           |           |
|           |           |------+
|           |           |      |
|           |           |      空值：表示什么也没有;类型检查后会返回一个object    类型：Null
|           |           |
|           |           |------+
|           |           |      未定义：声明一个变量没有赋值时,它的值就是Undefined 类型：Undefined
|           |           |
|           |           |------+
|           |                  |
|           |                  符号：用来创建一个唯一表示                        类型：Symbol
|           |
|           |------+
|           |      |
|           |      对象(可变类型)：一种符合数据类型,相当于一个容器,在对象中可以存储各种不同类型的数据;使用对象来描述一个物体
|           |          |
|           |          |------+
|           |          |      |
|           |          |      定义：由多种类型数据复合而成的一个结构类型的变量,称之为对象
|           |          |            对象中存储的数据,称之为属性
|           |          |------+
|           |          |      |
|           |          |      变量和对象
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      修改对象：修改对象时,如果有其他变量指向该对象,则所有指向该对象的变量都会受到影响
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      修改变量：修改变量时,只会影响当前的变量()
|           |          |           |
|           |          |           |------+
|           |          |                  |
|           |          |                  注意：使用变量存储对象时,很容易因为改变变量指向的对象,提高代码的复杂度;通常情况下,声明存储对象的变量时会使用const
|           |          |                       const只是进制变量被重新赋值,对对象的修改没有任何影响
|           |          |                       const 对象名{
|           |          |                         属性名: 属性值,
|           |          |                         ...
|           |          |                       }
|           |          |------+
|           |          |      |
|           |          |      操  作
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      创建对象语法:
|           |          |           |        关键字 对象名{
|           |          |           |            属性名1: 属性值1,
|           |          |           |            属性名2: 属性值2,
|           |          |           |            ...
|           |          |           |        }
|           |          |           |            
|           |          |           |------+
|           |          |           |      |
|           |          |           |      向对象中添加属性：对象.属性名 = 属性值
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      读取对象中的属性：对象.属性名 (读取一个对象中没有的属性不会报错,而是undefined)
|           |          |           |
|           |          |           |------+
|           |          |                  |
|           |          |                  修改对象中的属性：对象.属性名 = 新_属性值
|           |          |
|           |          |------+
|           |          |      |
|           |          |      对象的属性
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      属性名：是一个字符串
|           |          |           |             属性名可以是任何值,没有特殊要求;
|           |          |           |             特殊的属性名需要用[]来设置,例如：let obj= Object();obj["字符串"] =  值;使用对象作为属性名：let mySymbol = Symbol(); obj[mySymbol] = 值
|           |          |           |             可以使用符号(symbol)作为属性名,来添加属性;
|           |          |           |             属性名可以看做是一种记好,用哪一个属性名存放元素,就需要用哪一个属性名读取元素
|           |          |           |             使用[]去操作属性时,可以使用变量：let str = "address"; obj["address"] = 值; // obj[str] = 值 等价于 obj["address"] = 值
|           |          |           |             使用.去添加属性时,不能使用变量
|           |          |           |
|           |          |           |
|           |          |           |------+
|           |          |                  |
|           |          |                  属性值：对象的属性值,可以是任意的数据类型,也可以是一个对象(函数也可以成为一个对象的属性)
|           |          |                         obj.属性名.属性名    //对象的对象
|           |          |                         使用typeof检查一个对象时,会返回object
|           |          |
|           |          |------+
|           |          |      |
|           |          |      对象字面量
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      定义：对象字面量由 {} 包裹,内部是 属性名: 值 的形式
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      创建：可以直接使用{}来创建对象,使用{}所创建的对象，可以直接向对象中添加属性
|           |          |           |            let obj ={
|           |          |           |                name:"xiaolee",
|           |          |           |                age:18,
|           |          |           |                ["sex"]:"boy"
|           |          |           |                } 
|           |          |           | 
|           |          |           |------+
|           |          |                  |
|           |          |                  语法：
|           |          |                    {
|           |          |                        属性名:属性值,
|           |          |                        [属性名]:属性值.
|           |          |                    }            
|           |          |
|           |          |------+
|           |          |      |
|           |          |     枚举对象
|           |          |           |
|           |          |           |------+
|           |          |           |      |
|           |          |           |      枚举属性：指将对象中的所有属性全部获取(一一列举出来)
|           |          |           |
|           |          |           |------+
|           |          |                  |
|           |          |                  for-in语句：实现对对象中的所有属性的枚举
|           |          |                       |
|           |          |                       |------+
|           |          |                       |      |
|           |          |                       |      语法：
|           |          |                       |       for(let 属性名 in 对象){
|           |          |                       |            语句...
|           |          |                       |       }     
|           |          |                       |    //访问属性名
|           |          |                       |       for(let propName in obj){
|           |          |                       |            console.log(propName)
|           |          |                       |       }     
|           |          |                       |   //访问属性值
|           |          |                       |       for(let propName in obj){
|           |          |                       |            console.log(obj[propName])
|           |          |                       |       }     
|           |          |                       |
|           |          |                       |------+
|           |          |                              |
|           |          |                              执行流程：for-in的循环体会执行多次,直至对象中的所有可以被访问的属性全部被枚举(并不是所有的属性都可以枚举,比如使用符号添加的属性不可以被枚举);
|           |          |                                       每次执行时,都会将一个属性名赋值给所定义的变量
|           |          |
|           |          |------+
|           |                 |
|           |                 方  法
|           |                      |
|           |                      |------+
|           |                      |      |
|           |                      |      定义：当一个对象的属性指向一个函数,就称这个函数是该对象的方法,调用函数就成为调用对象的方法
|           |                      |
|           |                      |------+
|           |                      |      |
|           |                      |      语法：
|           |                      |      对象名.函数属性()      
|           |                      |
|           |                      |------+
|           |                             |
|           |                             注意：调用对象的方法与调用函数本质上都是调用一个函数,并无差异;对象仅仅是对函数进行分类
|           |                                       
|           |------+    
|                  |
|                  类型转换
|                       |
|                       |------+
|                       |      |
|                       |      定义：将一种数据类型转换为其他类型
|                       |
|                       |------+
|                       |      |
|                       |      转换方式
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      显式转换：用户可以直接从源代码中读取到存在类型转换的语句
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  隐式转换：用户无法直接从源代码中读取到类型转换的语句，但是编译器完成了从一种类型到另一种类型的转换
|                       |
|                       |------+
|                              |
|                              方  法 
|                                   |
|                                   |------+
|                                   |      |
|                                   |      转换为字符串：toString()方法;null和undefined无法使用toString()方法
|                                   |
|                                   |------+
|                                   |      |
|                                   |      转换为数值
|                                   |           |
|                                   |           |------+
|                                   |           |      |
|                                   |           |     Number()方法
|                                   |           |           |
|                                   |           |           |------+
|                                   |           |           |      |
|                                   |           |           |      合法字符串自动转换为对应的数字;不合法数字转换为NaN;字符串是空串或纯空格字符串，转换为0
|                                   |           |           |
|                                   |           |           |------+
|                                   |           |           |      |
|                                   |           |           |      布尔值:true 转换为1;false转换为0
|                                   |           |           |
|                                   |           |           |------+
|                                   |           |           |      |
|                                   |           |           |      null:转换为0
|                                   |           |           |------+
|                                   |           |                  |
|                                   |           |                  Undefined：转换为NaN
|                                   |           |
|                                   |           |------+
|                                   |           |      |
|                                   |           |      parseInt()方法(只适用于字符串)
|                                   |           |           |
|                                   |           |           |------+
|                                   |           |                  |
|                                   |           |                  将一个字符串转换为一个整数
|                                   |           |
|                                   |           |------+
|                                   |                  |
|                                   |                  parseFloat()方法(只适用于字符串)
|                                   |                       |
|                                   |                       |------+
|                                   |                              |
|                                   |                              将一个字符串转换为浮点数）
|                                   |
|                                   |------+
|                                          |
|                                          转换为Boolean
|                                                |
|                                                |------+
|                                                       |
|                                                     Boolean()函数来将其他类型转换为布尔值
|                                                          |
|                                                          |------+
|                                                          |      | 
|                                                          |      数字：0和NaN转换为false;其余是true
|                                                          |
|                                                          |------+
|                                                          |      |
|                                                          |      字符串：空串转换为false;其余是true
|                                                          |
|                                                          |------+
|                                                          |      |
|                                                          |      null和undefined都转换为false
|                                                          |
|                                                          |------+
|                                                                 |
|                                                                 对象大部分情况下会转换为true;特殊情况会转换为false
|
|------+
|      |
|      运算符(n元运算符：表示操作数的个数为n个;根据操作数的个数来为运算符分类)    
|           |                   
|           |------+
|           |      |
|           |      算数运算符
|           |           |
|           |           |------+
|           |           |      |
|           |           |      运算符(操作符)：可以用来对一个或多个操作数(值)进行运算
|           |           |      
|           |           |------+
|           |           |      |
|           |           |      类  型
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      加法运算符：+
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      减法运算符：-
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      乘法运算符：*
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  除法运算符：%(取余);/(取整)
|           |           |
|           |           |------+
|           |                  |
|           |                  注  意
|           |                       |
|           |                       |------+
|           |                              |
|           |                              算数运算时，除了字符串的加法(两个或多个字符串合并为一个字符串),其他运算的操作数是非数值时,都会转换为数值然后进行运算
|           |                              任意一个值和字符串做加法运算时,会首先将值转换为字符串,然后做拼接字符串的操作
|           |
|           |------+
|           |      |
|           |      赋值运算符
|           |           |
|           |           |------+
|           |           |      |
|           |           |      作用：用来将一个值赋值给一个变量(右侧的值赋值给左边的变量)
|           |           |
|           |           |------+
|           |           |      |
|           |           |      类  型
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  赋值运算符：=
|           |           |
|           |           |------+
|           |                  |
|           |                  注  意
|           |                       |
|           |                       |------+
|           |                              |
|           |                              只有当变量的值为null或undefined时才会对变量进行不值
|           |
|           |------+
|           |      |
|           |      正负运算符
|           |             |
|           |             |------+
|           |             |     |
|           |             |      正号[+]：+变量(不会改变数值的符号)
|           |             |
|           |             |------+
|           |             |      |
|           |             |      负号[-]：-变量(表示对符号位取反)
|           |             |
|           |             |------+
|           |                    |
|           |                    注  意
|           |                          |
|           |                          |------+
|           |                                 |
|           |                                 对非数值进行正负运算时，先将其转换为数值,然后再进行运算
|           |           
|           |------+
|           |      |
|           |      自增减运算符
|           |             |
|           |             |------+
|           |             |      |
|           |             |      自增[++](使原来的变量立刻增加1)
|           |             |           |
|           |             |           |------+
|           |             |           |      |
|           |             |           |      变量++(表达式返回的值是自增前的值[旧值])
|           |             |           | 
|           |             |           |------+
|           |             |                  |
|           |             |                  ++变量(表达式返回的值是自增后的值[新值])
|           |             |
|           |             |------+
|           |                    |
|           |                    自减[++](使原来的变量立刻减少1)
|           |                         |
|           |                         |------+
|           |                         |      |
|           |                         |      变量--(表达式返回的值是自减前的值;[旧值])
|           |                         | 
|           |                         |------+
|           |                                |
|           |                                --变量(表达式返回的值是自减后的值[新值])
|           |             
|           |------+
|           |      |
|           |      逻辑运算符
|           |             |         
|           |             |------+
|           |             |      |
|           |             |      作用：进行逻辑运算(逻辑与、逻辑或)
|           |             |           
|           |             |------+
|           |                    |
|           |                    类  型
|           |                         |
|           |                         |------+
|           |                         |      |
|           |                         |      逻辑非[!]：可以对一个值进行非运算(非运算是一种按位取反的运算,返回结果是布尔类型的值)
|           |                         |               对一个非布尔值进行取反，会先将其转换为Boolean类型,然后再取反
|           |                         |
|           |                         |------+
|           |                         |      |
|           |                         |      逻辑与[&&]：可以对两个值进行与运算(左右两边同时为true时，返回true;存在false时,返回false;短路与：如果第一个值为false,则不判断第二个值)
|           |                         |           |
|           |                         |           |------+
|           |                         |           |      |
|           |                         |           |      true：左表达式[true] && 右表达式[true]
|           |                         |           |
|           |                         |           |------+
|           |                         |                  |
|           |                         |                  false
|           |                         |                      |
|           |                         |                      |------+
|           |                         |                      |      |
|           |                         |                      |      左表达式[true] && 右表达式[false]
|           |                         |                      | 
|           |                         |                      |
|           |                         |                      |------+
|           |                         |                      |      |
|           |                         |                      |      左表达式[false] && 右表达式[true](短路与)
|           |                         |                      | 
|           |                         |                      |
|           |                         |                      |------+
|           |                         |                             |
|           |                         |                             左表达式[fasle] && 右表达式[fasle](短路与)
|           |                         |                    
|           |                         |------+
|           |                                |
|           |                                逻辑或[||]：可以对两个值进行或运算(左右两边右ture时，返回true;左右两边均为false时，参会false)
|           |                                     |
|           |                                     |------+
|           |                                     |      |
|           |                                     |      true：左表达式[true] || 右表达式[true]
|           |                                     |           |
|           |                                     |           |------+
|           |                                     |           |      |
|           |                                     |           |      左表达式[true] || 右表达式[ture]
|           |                                     |           | 
|           |                                     |           |
|           |                                     |           |------+
|           |                                     |           |      |
|           |                                     |           |      左表达式[ture] || 右表达式[false]
|           |                                     |           | 
|           |                                     |           |
|           |                                     |           |------+
|           |                                     |                  |
|           |                                     |                  左表达式[fasle] || 右表达式[ture]
|           |                                     |
|           |                                     |------+
|           |                                            |
|           |                                            false：左表达式[false] || 右表达式[false]
|           |                  
|           |------+
|           |      |
|           |      关系运算符
|           |           |
|           |           |------+
|           |           |      |
|           |           |      作用： 检查两个值之间的关系是否成立;成立返回true,不成立返回false
|           |           |
|           |           |------+
|           |           |      |
|           |           |      类  型
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      大于[>]：用来检查左值是否大于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |            |      |
|           |           |           |            |      true：左值大于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |                   |
|           |           |           |                   false：左值小于右值;左值等于右值
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      大于或等于[>=]：用来检查左值是否大于右值或者等于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |            |      |
|           |           |           |            |      true：左值大于右值;左值等于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |                   |
|           |           |           |                   false：左值小于右值
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      小于[<]：用来检查左值是否小于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |            |      |
|           |           |           |            |      true：左值小于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |                   |
|           |           |           |                   false：左值大于右值;左值等于右值
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      小于或等于[<=]：用来检查左值是否小于右值或者等于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |            |      |
|           |           |           |            |      true：左值小于右值;左值等于右值
|           |           |           |            |
|           |           |           |            |------+
|           |           |           |                   |
|           |           |           |                   false：左值等于右值
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  相等运算符
|           |           |                       |------+
|           |           |                       |      |
|           |           |                       |      等于[==]：用来检查左值是否等于右值(会进行类型转换)
|           |           |                       |             |
|           |           |                       |             |------+
|           |           |                       |             |      |
|           |           |                       |             |      true：左值大于右值;左值等于右值
|           |           |                       |             |
|           |           |                       |             |------+
|           |           |                       |                    |
|           |           |                       |                    fasle：左值小于右值
|           |           |                       |
|           |           |                       |------+
|           |           |                       |      |
|           |           |                       |      全等[===]：用来检查左值是否全等与右值(不会进行类型转换)
|           |           |                       |            |
|           |           |                       |            |------+
|           |           |                       |            |      |
|           |           |                       |            |      true：左值等于右值,且左值数据类型与右值数据类型相同
|           |           |                       |            |
|           |           |                       |            |------+
|           |           |                       |                   |
|           |           |                       |                   fasle：左值不等于右值,即使左值等于右值,但数据类型不同仍返回false 
|           |           |                       |
|           |           |                       |------+
|           |           |                       |      |
|           |           |                       |      不等于[!=]：用来检查左值是否不等于右值(会进行类型转换)
|           |           |                       |            |
|           |           |                       |            |------+
|           |           |                       |            |      |
|           |           |                       |            |      true：左值不等于右值
|           |           |                       |            |
|           |           |                       |            |------+
|           |           |                       |                   |
|           |           |                       |                   fasle：左值等于右值;
|           |           |                       |
|           |           |                       |------+
|           |           |                              |
|           |           |                              不全等[!==]：用来检查左值是否不全等于右值(不会进行类型转换)
|           |           |                                    |
|           |           |                                    |------+
|           |           |                                    |      |
|           |           |                                    |      true：左值不全等于右值(数值不相等;数据类型也不相等)
|           |           |                                    |
|           |           |                                    |------+
|           |           |                                           |
|           |           |                                           fasle：左值等于右值(数值相等;数据类型也相等);
|           |           |                       
|           |           |------+
|           |                  |
|           |                  注  意
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      对关系运算符的两端是一个数值与非数值,会先将其转换为数值然后再比较
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      当关系运算符的两端是两个字符串,不会将字符串转换为数值,而是逐位(字符串的每一个元素)比较字符的Unicode编码 
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      相等运算符在比较不同类型的值时，会将其转换为相同类型(通常转换为数值),然后再比较;null和undefined相等比较会返回ture;NaN不和任何值相等,包括它自身
|           |                       |
|           |                       |------+
|           |                              |
|           |                              null和undefined进行全等比较时会返回false
|           |
|           |------+
|                  |
|                  条件运算符
|                       |
|                       |------+
|                       |      |
|                       |      结  构
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  条件表达式 ? 表达式1 : 表达式2
|                       |
|                       |------+
|                              |
|                              执行顺序
|                                   |
|                                   |------+
|                                          |
|                                          对条件表达式进行求值判断
|                                               |
|                                               |------+
|                                               |      |
|                                               |      true：执行表达式1
|                                               |
|                                               |------+
|                                                      |
|                                                      false：执行表达式2
|
|------+
|      |
|      运算符的优先级
|           |
|           |------+
|           |      |
|           |      ()：优先级最高
|           |
|           |------+
|           |      |
|           |      *、/、%：优先级大于+、-
|           |
|           |------+
|                  |
|                  查询运算符优先级网站：https://developer.mozilla.org/en-US/docs/Web/JavaScript
|------+
|      |
|      代码块
|           |
|           |------+
|           |      |
|           |      形  式
|           |           |
|           |           |------+
|           |                  |
|           |                  {}：使用{}来创建代码块.代码块可以用来对代码进行分组
|           |
|           |------+
|                  特  性
|                       |
|                       |------+
|                       |      |
|                       |      同一个代码块中的代码,就是同一组代码      
|                       |
|                       |------+
|                       |      |
|                       |      一个代码块中的代码,要么都执行;要么都不执行
|                       |
|                       |------+
|                              |
|                              作用域
|                                   |
|                                   |------+
|                                   |      |
|                                   |      代码块作用域：仅仅可以在代码块内部的成员可以访问(let声明的变量具有块作用域)
|                                   |
|                                   |------+
|                                          |
|                                          全局作用域：可以在整个代码中进行访问(var声明的变量具有全局作用域)
|
|------+
|      |
|      流程控制语句
|           |
|           |------+
|           |      |
|           |      作用：用来改变程序执行的顺序
|           |
|           |------+
|           |      |
|           |      控制关键字
|           |           |
|           |           |------+
|           |           |      |
|           |           |      break:用来终止switch和循环语句;break执行后,当前的switch或循环会立刻停止;只会终止break语句所在的循环
|           |           |
|           |           |------+
|           |                  |
|           |                  continue:用来跳过本次循环
|           |
|           |------+
|                  |
|                  类  型
|                       |
|                       |------+
|                       |      |
|                       |      if语句
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      语法：
|                       |           |        if(条件表达式)
|                       |           |           语句   
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      执行流程：if语句在执行时,会先对if后的条件表达式进行求值判断
|                       |           |           |
|                       |           |           |------+
|                       |           |           |      |
|                       |           |           |      true：执行if后的语句(条件表达式的返回值为布尔类型的true)
|                       |           |           |
|                       |           |           |------+
|                       |           |                  |
|                       |           |                  false：不执行if后的语句(条件表达式的返回值为布尔类型的false)
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      控制流程
|                       |           |           |
|                       |           |           |------+
|                       |           |           |      |
|                       |           |           |      单行代码:if(条件表达式)  语句
|                       |           |           |           控制紧随其后的那一行代码
|                       |           |           |
|                       |           |           |------+
|                       |           |                  |
|                       |           |                  多行代码：if(条件表达式) {语句1;语句2;...}
|                       |           |                       控制紧随其后的那一段代码块
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  控制类型
|                       |                       |
|                       |                       |------+
|                       |                       |      |
|                       |                       |      if语句中的条件表达式的返回类型是布尔类型
|                       |                       |
|                       |                       |------+
|                       |                              |
|                       |                              if语句后的条件表达式的值不是布尔类型,会先将其转换为布尔类型然后再运算
|                       |
|                       |------+
|                       |      |
|                       |      if-else语句
|                       |          |
|                       |          |------+
|                       |          |      |
|                       |          |      语法:
|                       |          |        if(条件表达式){
|                       |          |            语句1;
|                       |          |            语句2;
|                       |          |            ...   
|                       |          |        }else{
|                       |          |            语句1;
|                       |          |            语句2;
|                       |          |            ...  
|                       |          |        }
|                       |          |
|                       |          |------+
|                       |                 |
|                       |                 执行流程：if-else执行时，先对条件表达式进行求值判断
|                       |                      |
|                       |                      |------+
|                       |                      |      |
|                       |                      |      true：执行if后的语句
|                       |                      |
|                       |                      |------+
|                       |                             |
|                       |                             false：执行else后的语句    
|                       |
|                       |------+
|                       |      |
|                       |      if-else if-else语句
|                       |          |
|                       |          |------+
|                       |          |      |
|                       |          |      语法:
|                       |          |        if(条件表达式){
|                       |          |            语句...
|                       |          |        }else if(条件表达式){
|                       |          |            语句...
|                       |          |        }else if(条件表达式){
|                       |          |            语句...
|                       |          |        }else{
|                       |          |            语句...
|                       |          |        }
|                       |          |
|                       |          |------+
|                       |          |      |
|                       |          |       执行流程：if-else if-else语句会自上向下依次对if后的条件表达式进行求值判断
|                       |          |            |
|                       |          |            |------+
|                       |          |            |      |
|                       |          |            |      true：执行当前if后的语句/代码块，执行完毕,if-else if-else语句结束
|                       |          |            |
|                       |          |            |------+
|                       |          |                   |
|                       |          |                   false：不执行if后的语句，继续对下一个条件表达式进行判断,直至找到if后的条件表达式返回值为true
|                       |          |                           如果结尾没有写else,且if后的表达式判断均为false,则不执行任何if后的语句/代码块
|                       |          |                           如果结尾写了else,且if后的表达式判断均为false,则执行else后的语句/代码块
|                       |          |
|                       |          |------+
|                       |                 |
|                       |                 注  意：if-else if-else语句中只会有一个代码块被执行,若有被执行的代码块，则后续的条件表达式都不会继续被判断
|                       |
|                       |------+
|                       |      |
|                       |      switch语句
|                       |          |
|                       |          |------+
|                       |          |      |
|                       |          |      语法:
|                       |          |        switch(表达式){
|                       |          |           case 表达式:
|                       |          |               代码...
|                       |          |           case 表达式:
|                       |          |               代码...
|                       |          |           case 表达式:
|                       |          |               代码...
|                       |          |           default:
|                       |          |               代码...
|                       |          |        }
|                       |          |
|                       |          |------+
|                       |                 |
|                       |                 执行流程：switch语句在执行时，会依次将switch后的表达式和case后的表达式进行全等比较
|                       |                      |
|                       |                      |------+
|                       |                      |      |
|                       |                      |      true：自当前case出开始执行代码(当前case后的代码均会被执行)
|                       |                      |------+
|                       |                             |
|                       |                             false：继续比较其他case后的表达式,直至找到true
|                       |                                    所有的比较都是false,则执行default后的语句(default与case的顺序可以变化)
|                       |
|                       |------+
|                              |
|                              循环语句
|                                  |
|                                  |------+
|                                  |      |
|                                  |      作用：可以使指定的代码反复执行
|                                  |
|                                  |------+
|                                  |      |
|                                  |      要  点
|                                  |           |
|                                  |           |------+
|                                  |           |      |
|                                  |           |      死循环：条件表达式恒为true时，是一个死循环,会一直执行
|                                  |           |------+
|                                  |           |      |
|                                  |           |      语法：
|                                  |           |        for(;;){语句...}
|                                  |           |        while(true){语句...}     //使用true需要引用头文件:stdbool.h
|                                  |           |
|                                  |           |------+
|                                  |                  |
|                                  |                  编写一个循环的三个要件
|                                  |                       |
|                                  |                       |------+
|                                  |                       |      |
|                                  |                       |      1.初始化表达式(初始化变量)
|                                  |                       |
|                                  |                       |------+
|                                  |                       |      |
|                                  |                       |      2.条件表达式(设置循环运行的条件)
|                                  |                       |
|                                  |                       |------+
|                                  |                              |
|                                  |                              3.更新表达式(修改初始化变量)
|                                  |
|                                  |------+
|                                         |
|                                         类  型
|                                              |
|                                              |------+
|                                              |      |
|                                              |      while语句
|                                              |          |
|                                              |          |------+
|                                              |          |      |
|                                              |          |     语法：
|                                              |          |        while(条件表达式){
|                                              |          |           语句...
|                                              |          |         }
|                                              |          |------+
|                                              |                 |
|                                              |                 执行流程：先对条件表达式进行判断
|                                              |                      |
|                                              |                      |------+
|                                              |                      |      |
|                                              |                      |      结果为true：执行循环体;执行完毕后,继续判断
|                                              |                      |                 
|                                              |                      |
|                                              |                      |------+
|                                              |                             |
|                                              |                             结果为false：循环结束,不再执行while循环
|                                              |------+
|                                              |      |
|                                              |      do-while语句
|                                              |          |
|                                              |          |------+
|                                              |          |      |
|                                              |          |     语法：
|                                              |          |        do{
|                                              |          |           语句...
|                                              |          |         }while(条件表达式)
|                                              |          |------+
|                                              |                 |
|                                              |                 执行流程：先执行一次循环体;然后对条件表达式进行判断
|                                              |                      |
|                                              |                      |------+
|                                              |                      |      |
|                                              |                      |      结果为true：执行循环体;执行完毕后,继续判断
|                                              |                      |                 
|                                              |                      |
|                                              |                      |------+
|                                              |                             |
|                                              |                             结果为false：循环结束,不再执行do-while循环
|                                              |
|                                              |------+
|                                                     |
|                                                     for语句
|                                                        |
|                                                        |------+
|                                                        |      | 
|                                                        |      语法：
|                                                        |        for(初始化表达式;条件表达式;更新表达式){
|                                                        |              语句...
|                                                        |          }    
|                                                        |------+
|                                                        |      |
|                                                        |      执行流程：执行初始化表达式,初始化变量;执行条件表达式,判断循环是否执行
|                                                        |           |
|                                                        |           |------+
|                                                        |           |      |
|                                                        |           |      结果为true：执行循环体;执行完毕后,继续判断
|                                                        |           |
|                                                        |           |------+
|                                                        |                  |
|                                                        |                  结果为false：循环结束,不再执行For循环
|                                                        |
|                                                        |------+
|                                                               |
|                                                               注  意
|                                                                    |
|                                                                    |------+
|                                                                    |      |
|                                                                    |      1.初始化表达式,在循环的整个生命周期中只会执行一次
|                                                                    |      
|                                                                    |------+
|                                                                           |
|                                                                           2.for循环中的三个表达式都可以省略
|
|------+
|      |
|      函  数 
|           |
|           |------+
|           |      |
|           |      简  介
|           |           |
|           |           |------+
|           |           |      |
|           |           |      说明：函数也是一个对象;
|           |           |           它具有其他对象所有的功能;
|           |           |           函数中可以存储代码,且可以在需要时调用这些代码 
|           |           |
|           |           |------+
|           |           |      |
|           |           |      语法：
|           |           |        function 函数名(){
|           |           |           代码块...
|           |           |        }
|           |           |
|           |           |
|           |           |------+
|           |           |      |
|           |           |      调用函数：执行函数中存储的代码
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      语法：
|           |           |           |        函数对象()
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      通过call()方法调用：函数.call()
|           |           |           |      通过call()方法调用函数,函数的实参直接在第一个参数后,一个一个列举出来
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      通过apply()方法调用：函数.apply()
|           |           |           |      通过apply()方法调用函数,函数的实参需要通过一个数组传递
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                   注意：call()和apply()除了可以调用函数,还可以用来指定函数中的this
|           |           |                        call()和apply()的第一个参数,将会成为函数的this    
|           |           |                        语法：函数.call(参数1,参数2,...)
|           |           |                              函数.apply(参数1,[参数2,参数3,...])
|           |           |------+
|           |                  |
|           |                  类型检查：使用typeof检查函数对象时会返回function
|           |
|           |------+
|           |      |
|           |      分  类
|           |           |
|           |           |------+
|           |           |      |
|           |           |      普通函数：返回值是一些数据类型
|           |           |
|           |           |------+
|           |                  |
|           |                  高阶函数：返回值是一个函数
|           |------+
|           |      |
|           |      创建方式
|           |           |
|           |           |------+
|           |           |      |
|           |           |      1.函数声明
|           |           |             |
|           |           |             |------+
|           |           |                    |
|           |           |                    语法：
|           |           |                      function 函数名(参数1,参数2,...){
|           |           |                           语句...
|           |           |                      }
|           |           |
|           |           |------+
|           |           |      |
|           |           |      2.函数表达式
|           |           |             |
|           |           |             |------+
|           |           |                    |
|           |           |                    语法：
|           |           |                       const 变量 = function(参数1,参数2,...){
|           |           |                            语句...
|           |           |                       } 
|           |           |
|           |           |------+
|           |                  |
|           |                  3.箭头函数(匿名函数)
|           |                         |
|           |                         |------+
|           |                         |      |
|           |                         |      语法：
|           |                         |         (参数1,参数2,...) => {
|           |                         |              语句...
|           |                         |         } 
|           |                         |
|           |                         |------+
|           |                         |      |
|           |                         |      调用：const 函数名 = (参数1,参数2,...) => {
|           |                         |                 语句...
|           |                         |            }
|           |                         |
|           |                         |-----+
|           |                               |
|           |                               参  数
|           |                                    |
|           |                                    |-----+
|           |                                    |     |
|           |                                    |     1.箭头函数中只有一个参数时,可以省略()
|           |                                    |       语法：
|           |                                    |         参数 =>{
|           |                                    |              代码块
|           |                                    |         }
|           |                                    |
|           |                                    |-----+
|           |                                          |
|           |                                          2.定义参数时,可以为参数指定默认值，默认值会在没有对应实参时生效
|           |                                            语法：
|           |                                              (参数1=值1,参数2=值2,参数3=值3,...) =>{
|           |                                                   代码块
|           |                                              }
|           |                                     
|           |------+
|           |      |
|           |      函数的参数
|           |           |
|           |           |------+
|           |           |      |
|           |           |      参数类型
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      形式参数：声明了变量但是没有赋值(函数内部声明变量但没有赋值的参数,称之为形式参数)
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  实际参数：声明了变量并且进行赋值(函数在调用过程中,()传递的一些值,称之为实际参数)
|           |           |
|           |           |------+
|           |           |      |
|           |           |      参数数量
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      实际参数和形式参数数量相同：对应的实际参数赋值给对应的形式参数
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      实际参数多于形式参数：多余的实际参数不会使用
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  实际参数少于形式参数：多余的形式参数为undefined
|           |           |
|           |           |------+
|           |           |      |
|           |           |      对象作为函数参数
|           |           |           |
|           |           |           |-----+
|           |           |           |     |
|           |           |           |     1.修改变量时,只会影响当前的变量;对象可以作为参数传递
|           |           |           |       修改对象时,如果有其他变量指向该对象,则所有指向该对象的变量都会受到影响
|           |           |           |
|           |           |           |-----+
|           |           |           |     |
|           |           |           |     2.传递实参时,传递并不是变量本身,而是变量中存储的值
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  3.函数每次调用,都会重新创建默认值
|           |           |------+
|           |           |      |
|           |           |      函数作为函数参数
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      1.js语言中,函数也是一个对象,其它对象可以做的操作,函数也可以实现
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      2.语法：
|           |           |           |        function fn(a){
|           |           |           |           console.log("a =",a)
|           |           |           |        }
|           |           |           |        function fn2(){
|           |           |           |           console.log("我是fn2")
|           |           |           |        }
|           |           |           |        fn(fn2)
|           |           |           |        输出结果：a =f fn2(){
|           |           |           |           console.log("我是fn2")
|           |           |           |        }
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  3.作用：可以动态的传递代码
|           |           |                    function fn(a){
|           |           |                       a()
|           |           |                    }
|           |           |                    function( () =>console.log("我是箭头函数") )
|           |           |                    输出结果：我是箭头函数
|           |           |
|           |           |------+
|           |           |      |
|           |           |      函数中的this
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      定义：函数在执行时,js解释器每次都会传递进一个隐含的参数,这个参数就叫做this
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      this：this所指向的对象会根据函数调用方式的不同而不同
|           |           |           |           |
|           |           |           |           |------+
|           |           |           |           |      |
|           |           |           |           |      1.以函数形式调用this时,this指向的是window
|           |           |           |           |
|           |           |           |           |------+
|           |           |           |           |      |
|           |           |           |           |      2.以方法的形式调用时,this指向的是调用方法的对象
|           |           |           |           |
|           |           |           |           |------+
|           |           |           |                  |
|           |           |           |                  3.构造函数中,this是新建的对象    
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      作用：通过this可以在方法中引用调用方法的对象(在本对象中访问本对象中的属性值)
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  箭头函数中的this
|           |           |                       |
|           |           |                       |------+
|           |           |                       |      |
|           |           |                       |      箭头函数格式
|           |           |                       |           |
|           |           |                       |           |------+
|           |           |                       |           |      |
|           |           |                       |           |      无参箭头函数：() => 返回值
|           |           |                       |           |
|           |           |                       |           |------+
|           |           |                       |           |      |
|           |           |                       |           |      一个参数的箭头函数：a => 返回值
|           |           |                       |           |       
|           |           |                       |           |------+
|           |           |                       |           |      |
|           |           |                       |           |      多个参数的箭头函数：(a,b) => 返回值
|           |           |                       |           |
|           |           |                       |           |------+
|           |           |                       |           |      |
|           |           |                       |           |      只有一个语句的箭头函数：() => 返回值
|           |           |                       |           |
|           |           |                       |           |------+
|           |           |                       |           |      |
|           |           |                       |           |      只返回一个对象的箭头函数：() => ({...})
|           |           |                       |           |
|           |           |                       |           |------+
|           |           |                       |                  |
|           |           |                       |                  有多行语句的箭头函数：() =>{
|           |           |                       |                                           语句...
|           |           |                       |                                           return 返回值
|           |           |                       |                                       }
|           |           |                       |
|           |           |                       |------+
|           |           |                              |
|           |           |                              箭头函数的this：箭头函数没有自己的this,它的this由外层定义域决定
|           |           |                                             箭头函数的this和它的调用方式无关,它的this对象是确定的,不变的
|           |           |
|           |           |------+
|           |           |      |
|           |           |      函数中的arguments
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      函数中的隐含参数,是一个类数组对象(伪数组)
|           |           |           |      类数组对象：和数组相似,可以通过索引来读取元素,也可以通过for循环变量,但是它不是一个数组对象,不能调用数组的方法
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      作用：用来存储函数的实参,无论用户是否定义形参,实参都会存储到arguments对象中,可以通过该对象访问实参
|           |           |           |           通过arguments可以不受参数数量的限制,更加灵活的创建函数
|           |           |           |------+
|           |           |                  |
|           |           |                  缺点：1.使用别人的函数,不能确定参数数量
|           |           |                       2.arguments不是一个数组,不能使用数组的方法
|           |           |------+
|           |           |      |
|           |           |      可变参数
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      在定义函数时,可以将参数指定为可变参数
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      作用：可变参数可以接收任意数量实参,并将他们统一存储到一个数组中返回
|           |           |           |           可变参数的作用和arguments基本一致,但是也具有一些不同点：
|           |           |           |               1.可变参数的名字可以自己指定
|           |           |           |               2.可变参数就是一个数组,可以直接使用数组的方法  
|           |           |           |               3.可变参数可以配合其他参数一起使用,并按照从左往右的顺序传递参数 
|           |           |           |------+
|           |           |                  |
|           |           |                  语法：
|           |           |                  function 函数名(...[参数名]){语句...}                 //可变参数单独使用
|           |           |                  此时[参数名]就表示一个可变参数
|           |           |                  function 函数名(参数1,参数2,...,...[参数名]){语句...}  //可变参数与其他参数配合使用
|           |           |------+
|           |                  |
|           |                  注意：js语言中,函数不会检查传入参数的类型;为了确保传入正确的数据类型,要进行类型转换
|           |
|           |-----+
|           |     |
|           |     函数的返回值
|           |          |
|           |          |------+
|           |          |      |
|           |          |      普通函数
|           |          |           |
|           |          |           |------+
|           |          |                  |
|           |          |                  返回值 
|           |          |                       |
|           |          |                       |------+
|           |          |                       |      |
|           |          |                       |      1.在函数中,可以通过return关键字来制定函数的返回值
|           |          |                       |
|           |          |                       |------+
|           |          |                       |      |
|           |          |                       |      2.返回值就是函数的执行结果,函数调用完毕返回值便会作为结果返回
|           |          |                       |
|           |          |                       |------+
|           |          |                       |      |
|           |          |                       |      3.可以使用一个变量来接收函数的返回值
|           |          |                       |
|           |          |                       |------+
|           |          |                       |      |
|           |          |                       |      4.任何值都可以作为返回值使用(包括对象和函数);如果return后不跟任何值,相当于返回undefined 
|           |          |                       |        如果不写return,函数的返回值依然是undefined   
|           |          |                       |
|           |          |                       |------+
|           |          |                              |
|           |          |                              5.return执行后,函数立即结束
|           |          |
|           |          |------+
|           |                 |
|           |                 箭头函数
|           |                      |
|           |                      |------+
|           |                             |
|           |                             返回值
|           |                                  |
|           |                                  |------+
|           |                                  |      |
|           |                                  |      1.箭头函数的返回值可以直接写在箭头后：const sum = (a + b) => [a + b]([]内是返回值)
|           |                                  |
|           |                                  |------+
|           |                                         |
|           |                                         2.如果直接在箭头后设置对象字面量为返回值时,对象字面量必须使用()括起来：const fn = () =>({属性名:值}) (()内是返回值)   
|           |
|           |------+
|           |      |
|           |      立即执行函数(IIFE)
|           |           |
|           |           |------+
|           |           |      |
|           |           |      作用：希望可以创建一个只执行一次的匿名函数(这个函数是一个匿名的函数,并且只会调用一次)
|           |           |            可以利用IIFE来创建一个一次性的函数作用域,避免变量冲突的问题
|           |           |
|           |           |------+
|           |                  |
|           |                  语法：
|           |                   (function(){
|           |                       语句...
|           |                   })() 
|           |                   或
|           |                   (function(){
|           |                       语句...
|           |                   }())
|           |
|           |------+
|           |      |
|           |      封装函数
|           |           |
|           |           |------+
|           |                  |
|           |                  格式: 
|           |                     function 函数名(){
|           |                         /*封装的代码*/
|           |                         语句...         
|           |                         return [返回值]
|           |                      }
|           |
|           |------+
|           |      |
|           |      高阶函数
|           |           |
|           |           |------+
|           |           |      |
|           |           |      如果一个函数的参数或返回值是函数,则这个函数就称为高阶函数
|           |           |      将函数作为参数,意味着可以对另一个函数动态的传递代码
|           |           |      可以通过高阶函数,来动态的生成一个新函数
|           |           |
|           |           |------+
|           |           |      |
|           |           |      格式: 
|           |           |          function 函数名(){
|           |           |             语句...
|           |           |             return [函数]
|           |           |           }
|           |           |
|           |           |------+
|           |                  |
|           |                  方  法
|           |                       |
|           |                       |------+
|           |                              |
|           |                              bind()：可以用来创建一个新的函数
|           |                              语法：变量 = 函数.bind(参数1,参数2,参数3,...)    //不会执行函数,而是返回一个新的函数
|           |                              作用：可以为新函数绑定this
|           |                                    可以为新函数绑定参数
|           |                               箭头函数没有自身的this,它的this由外层作用域决定,也无法通过call(),apply(),和bind()修改它的this
|           |                               箭头函数中没有arguments
|           |------+
|           |      |
|           |      闭  包
|           |           |
|           |           |------+
|           |           |      |
|           |           |      定义：闭包就是能访问到外部函数作用域中变量的函数
|           |           |      
|           |           |------+
|           |           |      |
|           |           |      使用闭包：需要隐藏一些不希望别人访问的内容时就可以使用闭包
|           |           |
|           |           |------+
|           |           |      |
|           |           |      构造闭包的要件
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      1.函数的嵌套
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      2.内部函数要引用外部函数中的变量
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  3.内部函数要作为返回值返回
|           |           |
|           |           |------+
|           |           |      |
|           |           |      闭包的原理
|           |           |          函数作用域在函数创建时就已经确定了(词法作用域),和调用的位置无关
|           |           |          闭包利用的就是词法作用域
|           |           |
|           |           |------+
|           |                  |
|           |                  闭包的注意事项
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      闭包的声明周期
|           |                       |           |
|           |                       |           |------+
|           |                       |           |      |
|           |                       |           |      1.闭包在外部函数调用时产生,外部函数每次调用都会产生一个全新的闭包
|           |                       |           |
|           |                       |           |------+
|           |                       |                  |
|           |                       |                  2.在内部函数丢失时销毁(内存函数被垃圾回收了,闭包才会消失)
|           |                       |
|           |                       |------+
|           |                              |
|           |                              注意事项：闭包主要用来隐藏一些不希望被外部访问的内容,这就意味着必要需要占用一定的内存空间
|           |                                        相较于类来说,闭包比较浪费内存空间(类可以使用原型,闭包不能)
|           |                                        需要执行次数较少时,使用闭包
|           |                                        需要大量创建实例时,使用类
|           |
|           |------+
|                  |
|                  递  归
|                       |
|                       |------+
|                       |      |
|                       |      简  介
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      1.调用自身的函数称为递归函数
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  2.递归的作用和循环基本一致
|                       |
|                       |------+
|                       |      |
|                       |      核心思想：将一个大的问题拆分为一个一个小的问题,小的问题解决了,大的问题也解决了
|                       |
|                       |------+
|                       |      |
|                       |      递归函数要件
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      1.基线条件(递归的终止条件)
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  2.递归条件
|                       |
|                       |------+
|                              |
|                              递归的作用和循环的作用是一致的
|                              不同点在于：递归的思路比较清晰简洁;循环执行性能比较好
|                              在开发中,一般的问题都可以通过循环解决,尽量使用循环,少用递归
|                              通过循环不容易去解决的时候,使用递归
|------+
|      |
|      作用域
|           |
|           |------+
|           |      |
|           |      定义：一个变量的可见区域
|           |
|           |------+
|           |      |
|           |      建议：在开发中尽量减少直接在全局作用域中编写代码(避免变量值被别人修改),尽量在局部作用域中编写代码
|           |            使用let声明的变量,可以使用{}来创建块作用域  
|           |
|           |------+
|                  |
|                  类  型
|                       |
|                       |------+
|                       |      |
|                       |      全局作用域
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      1.在网页运行时创建,在网页关闭时销毁
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      2.所有直接编写到script标签中的代码都位于全局作用域中
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  3.全局作用域中 变量是全局变量,可以在任意位置访问
|                       |
|                       |------+
|                       |      |
|                       |      局部作用域
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      块作用域
|                       |           |           |
|                       |           |           |------+
|                       |           |           |      |
|                       |           |           |      1.在代码块执行时创建,代码块执行完毕后销毁
|                       |           |           |
|                       |           |           |------+
|                       |           |                  |
|                       |           |                  2.在块作用域中声明的变量是局部变量,只能在块内部访问,块外部无法访问
|                       |           |------+
|                       |                  |
|                       |                  函数作用域
|                       |                       |
|                       |                       |------+
|                       |                       |      |
|                       |                       |      1.在函数调用时产生,调用结束后销毁
|                       |                       |
|                       |                       |------+
|                       |                       |      |
|                       |                       |      2.函数每次调用都会产生一个全新的函数作用域,每一次调用都产生一个全新的作用域
|                       |                       |
|                       |                       |------+
|                       |                              |
|                       |                              3.在函数中定义的是局部变量,只能在函数内部进行访问,函数外部无法进行访问
|                       |
|                       |------+
|                       |      |
|                       |      提  升
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      变量的提升：使用var声明的变量,他会在所有代码执行前被声明,因此可以在变量声明前就访问变量
|                       |           |                 let声明的变量实际也会提升,但是在赋值之前解释器禁止对该变量的访问
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  函数的提升：使用函数声明创建的函数,会在其他代码执行前被创建,因此可以在函数声明前调用函数
|                       |------+
|                              |
|                              作用域链：当使用一个变量时,js解释器会优先在当前作用域中寻找变量
|                                   |
|                                   |------+
|                                   |      |
|                                   |      如果找到了,直接使用这个变量
|                                   |
|                                   |------+
|                                          |
|                                          如果没找到,则去上一层作用域中寻找,找到了则使用;没有找到则继续去上一层寻找,以此类推
|                                          如果一直到全局作用域都没有找到,则会报错：xxx 变量没有被定义
|
|------+
|      |
|      Window对象
|           |
|           |------+
|           |      |
|           |      在浏览器中,浏览器为我们提供了一个window对象,可以直接访问
|           | 
|           |------+
|           |      |
|           |      作用：window对象代表的是浏览器窗口,通过该对象可以对浏览器窗口进行各种操作
|           |            window对象还负责存储js中的内置对象(由语言内部所定义好的对象)和浏览器的宿主对象
|           |
|           |------+
|           |      |
|           |      访问：window对象的属性可以通过window对象访问(window.属性名),也可以直接访问(直接使用属性名访问)
|           |           函数可以认为是window对象的方法：使用window.函数名()格式来访问
|           |
|           |------+
|                  |
|                  注  意
|                       |
|                       |------+
|                       |      |
|                       |      1.var用来声明变量,作用和let箱通风,但是var不具有块作用域
|                       |        var虽然没有块作用域,但是有函数作用域(使用var在函数内部声明的变量无法通过window.进行访问)
|                       |        在局部作用域中,如果没有使用var或let声明变量,则变量Hi自动成为window对象的属性,也就是全局变量
|                       |
|                       |------+
|                       |      |
|                       |      2.在全局中使用var声明的变量,都会作为window对象的属性保存
|                       |
|                       |------+
|                       |      |
|                       |      3.使用function声明的函数,都会作为window的方法保存
|                       |
|                       |------+
|                              |
|                              4.使用let声明的变量不会存储在window中,而是存储在一个不可以通过window.进行访问的内存区域
|                                使用var声明的变量会存储在window中,可以通过window.进行访问
|                 
|------+
|      |
|      debug
|           |
|           |------+
|           |      |
|           |      作用：在代码出错时,对代码进行调试
|           |
|           |------+
|                  |
|                  debugger关键字：在代码中打印一个端点,用于暂停程序的执行
|
|------+
|      |
|      Js代码运行模式
|           |
|           |------+
|           |      |
|           |      正常模式：1.默认情况下,代码都运行在正常模式中
|           |               2.正常模式下,语法检查并不严格,语法检查原则是：能不报错的地方尽量不去报错
|           |               3.这种处理方式会导致代码的运行性能较差
|           |      
|           |------+
|                  |
|                  严格模式：1.严格模式下,语法检查更加严格
|                       |   2.禁止一些语法,更容易报错
|                       |   3.提升代码的运行性能
|                       |   4.在开发中尽量使用严格模式,可以将一些隐藏的问题消灭掉,也可以提升代码的运行性能
|                       |
|                       |------+
|                              |
|                              开启严格模式："use strict"
|                                   |
|                                   |------+
|                                   |      |
|                                   |      全局严格模式：在代码最外部开启严格模式
|                                   |
|                                   |------+
|                                          |
|                                          函数严格模式：在函数代码块中开启严格模式
|
|------+
|      |
|      面相对象(OOP)
|           |
|           |------+
|           |      |
|           |      引  例
|           |           |
|           |           |------+
|           |           |      |
|           |           |      1.程序的作用：程序是对现实世界的抽象
|           |           |
|           |           |------+
|           |                  |
|           |                  2.对象的作用：一个事物抽象到程序中后就变成了对象;在程序的世界中,一切皆对象
|           |
|           |------+
|           |      |
|           |      对象的组成
|           |           |
|           |           |------+
|           |           |      |
|           |           |      属性(现实世界中的数据,体现为属性)
|           |           |
|           |           |------+
|           |           |      |
|           |           |      方法(现实世界中的功能,体现为方法)
|           |           |
|           |           |------+
|           |                  |
|           |                  语法：
|           |                   const 对象名{
|           |                       //添加属性
|           |                         属性名1: 属性值1
|           |                         属性名2: 属性值2
|           |                         属性名3: 属性值3
|           |                         ...
|           |                       //添加方法
|           |                         函数名1(){
|           |                           语句...
|           |                         }
|           |                         函数名2(){
|           |                           语句...
|           |                         }
|           |                        函数名3(){
|           |                          语句...
|           |                         }
|           |                         ...               
|           |                    }
|           |
|           |------+
|           |      |
|           |      对象的结构
|           |           |
|           |           |------+
|           |           |      |
|           |           |      对象中存储属性的区域
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      对象自身：直接通过对象所添加的属性,位于对象自身中
|           |           |           |                   
|           |           |           |------+
|           |           |                  |
|           |           |                  原型对象：对象中还有一些内容,会存储到原型对象中
|           |           |                           对象中会有一个属性来存储原型对象,这个属性叫做__ptoto__
|           |           |                           原型对象也负责为对象存储属性：
|           |           |                               1.当访问对象中的属性时,会优先访问对象自身的属性
|           |           |                               2.对象不包含该属性时,才回去原型对象中寻找
|           |           |                           会添加到原型对象中的情况：
|           |           |                               1.在类中通过xxx(){}方式添加的方法,位于原型中
|           |           |                               2.主动向原型中添加的属性或方法
|           |           |
|           |           |------+
|           |                  |
|           |                  原型对象
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      访  问
|           |                       |           |
|           |                       |           |------+
|           |                       |           |      |
|           |                       |           |      1.访问一个对象的原型对象：对象.__proto__(不建议这样去访问)
|           |                       |           |
|           |                       |           |------+
|           |                       |                  |
|           |                       |                  2.标准访问方法：Object.getPrototypeOf(对象)
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      原型对象中的数据
|           |                       |           |
|           |                       |           |------+
|           |                       |           |      |
|           |                       |           |      1.对象中的数据(属性、方法等)
|           |                       |           |
|           |                       |           |------+
|           |                       |                  |
|           |                       |                  2.constructor(对象的构造函数)
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      原型链：原型对象中也有原型,这样就构成了一条原型链,根据对象的复杂程度不同,原型链的长度也不同
|           |                       |              读取对象属性时,会优先读取对象自身属性：
|           |                       |              如果对象中有,则使用,没有则去对象的原型中寻找
|           |                       |              如果原型中有,则使用,没有则去原型的原型中寻找
|           |                       |              直到找到Object对象的原型,Object的原型没有原型(为null)
|           |                       |              如果依然没有找到,则返回undefined
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      原型的作用：
|           |                       |           1.所有的同类型对象它们的原型对象都是同一个,即同类型对象的原型链是一样的
|           |                       |             可以将一个该类实例中所有的公共属性(方法)统一存储到原型中,这样我们只需要创建一个属性,即可被所有实例访问
|           |                       |           2.节约内存,避免属性值/方法的重复创建
|           |                       |
|           |                       |------+
|           |                              |
|           |                              修改原型
|           |                                   |
|           |                                   |------+
|           |                                   |      |
|           |                                   |      大部分情况下,我们是不需要修改原型对象
|           |                                   |
|           |                                   |------+
|           |                                   |      |
|           |                                   |      原  则
|           |                                   |           |
|           |                                   |           |------+
|           |                                   |           |      |
|           |                                   |           |      1.原型尽量不要手动改
|           |                                   |           |
|           |                                   |           |------+
|           |                                   |           |      |
|           |                                   |           |      2.要改也不要通过实例对象去修改
|           |                                   |           |
|           |                                   |           |------+
|           |                                   |           |      |
|           |                                   |           |      3.通过 类.prototype属性去修改
|           |                                   |           |
|           |                                   |           |------+
|           |                                   |                  |
|           |                                   |                  4.最好不要直接给prototype去赋值
|           |                                   |------+
|           |                                   |      |
|           |                                   |      修改方法
|           |                                   |           |
|           |                                   |           |------+
|           |                                   |           |      |
|           |                                   |           |      通过实例修改原型,向原型中添加方法,修改后所有同类实例都能访问该方法
|           |                                   |           |      实例.__proto__.run = () => {语句……}
|           |                                   |           |      不要通过类的实例去修改原型：
|           |                                   |           |           1.通过一个对象影响所有同类对象(不太合适)
|           |                                   |           |           2.修改原型需要先创建实例才能进行修改
|           |                                   |           |           3.不安全
|           |                                   |           |             实例.__proto__ = new 新类名()   //将原型修改为一个新类
|           |                                   |           |
|           |                                   |           |------+
|           |                                   |           |      |
|           |                                   |           |      通过类的prototype属性,来访问实例的原型
|           |                                   |           |
|           |                                   |           |------+
|           |                                   |                  |
|           |                                   |                  修改原型时,最好通过类去修改
|           |                                   |                  优点：1.一修改就是修改所有实例的原型
|           |                                   |                       2.无需创建实例即可完成对类的修改  
|           |                                   |
|           |                                   |------+
|           |                                          |
|           |                                          关于原型的运算符
|           |                                               |
|           |                                               |------+
|           |                                               |      |
|           |                                               |      instanceof：用来检查一个对象是否是一个类的实例
|           |                                               |           instanceOf检查的是对象的原型链上是否有该类实例,只要原型链上有该类实例,就会返回true
|           |                                               |           Object是所有对象的原型,所以任何对象和Object进行instanceof运算都会返回true
|           |                                               |
|           |                                               |------+
|           |                                               |      |
|           |                                               |      in：使用in运算符检查属性时,无论属性在对象自身还是在原型中,都会返回true
|           |                                               |
|           |                                               |------+
|           |                                                      |
|           |                                                      对象.hasOwnProperty(属性名)：用来检查一个对象的自身是否含有某个属性(不推荐使用)
|           |                                                      Object.hasOwn(对象,属性名)：用来检查一个对象的自身是否含有某个属性
|           |
|           |------+
|           |      |
|           |      对象的序列化
|           |           |
|           |           |------+
|           |           |      |
|           |           |     说明：js的对象使用时都是存在于计算机的内存中的
|           |           |           序列化指将对象转换为一个可以存储的格式,在js中对象的序列化通常是将一个对象转换为字符串(JSON字符串)
|           |           |     
|           |           |------+
|           |           |      |
|           |           |      作用：对象转化为字符串后可以将字符串在不同的语言之间进行传递,甚至可以直接对字符串进行读写操作,是的js对象可以在不同的语言之间传递
|           |           |           用于数据交换的格式
|           |           |           用来编写配置文字
|           |           |            
|           |           |------+
|           |           |      |
|           |           |      序列化：js中又一个工具类(json (javaScript Object Notation)   JS对象表示法)
|           |           |              js对象序列化后会换成一个字符串,这个字符串我们称其为json字符串
|           |           |              也可以手动的编写JSON字符串,很多程序的配置文件就是使用JSON编写
|           |           |              JSON字符串格式：'{"属性值1":"值1","属性值2":"值2","属性值3":"值3",...}'
|           |           |------+
|           |           |      |
|           |           |      转换方法：关键字声明 变量 = JSON.stringify(对象)    //JSON.stringify可以将一个JS对象转换为JSON字符串
|           |           |               关键字声明 对象名 = JSON.parse(JSON格式字符串)        //可以将一个JSON格式的字符串转捍卫JS对象
|           |           |
|           |           |------+
|           |           |      |
|           |           |      编写JSON的注意事项
|           |           |            |------+
|           |           |            |      |
|           |           |            |      JSON字符串的两种类型
|           |           |            |            |------+
|           |           |            |            |      |
|           |           |            |            |      1.JSON对象：{}    //表示一个JSON对象
|           |           |            |            |
|           |           |            |            |------+
|           |           |            |                   |
|           |           |            |                   2.JSON数组：[]    //表示一个JSON数组
|           |           |            |
|           |           |            |------+
|           |           |            |      |
|           |           |            |      2.JSON字符串的属性名必须使用双引号
|           |           |            |
|           |           |            |------+
|           |           |            |      |
|           |           |            |      3.JSON中可以使用的属性值(元素)
|           |           |            |        数字(Nubmer)
|           |           |            |        字符串(String)
|           |           |            |        布尔值(Boolean)
|           |           |            |        空值(null)
|           |           |            |        对象(Object{})
|           |           |            |        数组(Array [])
|           |           |            |
|           |           |            |------+
|           |           |                   |
|           |           |                   4.JSON的格式和JS对象的格式基本上一致
|           |           |                     但是JSON字符串的属性是最后一个,就不要再加逗号
|           |           |
|           |           |------+
|           |                  |
|           |                  JSON进行深刻复制
|           |                        |
|           |                        |------+
|           |                        |      |
|           |                        |      使用JSON字符串进行的复制是深复制     
|           |                        |
|           |                        |------+
|           |                               |
|           |                               语法：  关键字声明 变量1 = JSON.stringify(对象)
|           |                                      关键字声明 变量2 = JSON.parse(变量1)
|           |    
|           |------+
|           |      |
|           |      面相对象的编程步骤
|           |           |
|           |           |------+
|           |           |      |
|           |           |      1.找对象
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  对象的分类
|           |           |                       |
|           |           |                       |------+
|           |           |                       |      |
|           |           |                       |      内建对象：由ES标准所定义的对象,比如：Object、Function、String、Number……
|           |           |                       |
|           |           |                       |------+
|           |           |                       |      |
|           |           |                       |      宿主对象：由浏览器提供的对象,比如：BOM、DOM
|           |           |                       |
|           |           |                       |------+
|           |           |                              |
|           |           |                              自定义对象：由开发人员自己创建的对象
|           |           |
|           |           |------+
|           |                  |
|           |                  2.学习对象的方法
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      a.明确这个对象代表什么,有什么用
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      b.如何获取到这个对象
|           |                       |
|           |                       |------+
|           |                              |
|           |                              c.如何使用这个对象(对象中的属性和方法)
|           |------+    
|                  |
|                  面相对象的特点
|                       |
|                       |------+
|                       |      |
|                       |      封  装(安全性)
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      背景：
|                       |           |           1.对象是用来存储不同属性的容器
|                       |           |           2.对象不仅负责属性,还要负责数据的安全
|                       |           |           3.直接添加到对象中的属性,并不安全,因为它们可以被任意的修改
|                       |           |------+
|                       |           |      |
|                       |           |      如何确保数据安全？
|                       |           |           1.私有化数据：#属性名 = 属性值  /   private 属性名 = 属性值 //实例属性使用#前缀就变成了私有属性,私有属性只能在类内部访问(先声明私有类,然后在类中调用私有类：#属性名 this.#属性名)
|                       |           |           2.提供set_ter和get_ter方法来开放对数据的操作
|                       |           |                    |
|                       |           |                    |------+
|                       |           |                    |      |
|                       |           |                    |      set_ter方法：用来修改属性
|                       |           |                    |          语法：set方法名(变量){语句...}
|                       |           |                    |
|                       |           |                    |------+
|                       |           |                    |      |
|                       |           |                    |      get_ter方法：用来读取属性
|                       |           |                    |          语法：get方法名(){语句...}   /   get 方法名(){语句...}    调用：实例.get方法名    /   实例.方法名
|                       |           |                    |
|                       |           |                    |------+
|                       |           |                           |
|                       |           |                           优点：1.可以控制属性的读写权限
|                       |           |                                 2.可以在方法中对属性的值进行验证
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  意义：主要用来保证数据的安全,不能被随意访问
|                       |
|                       |------+
|                       |      |
|                       |      继  承(扩展性)
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      1.可以通过extends关键字来完成继承
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      2.当一个类被继承另一个类时,就相当于将另一个类中的代码复制到了当前类中
|                       |           |        语法：class 子类名 extends 父类名{语句...}
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      3.继承发生时,被继承的类称为父类,继承的类称为子类
|                       |           |           |
|                       |           |           |------+
|                       |           |           |      |
|                       |           |           |      a.重写：在子类中,可以通过创建同名方法来重写父类的方法(对于父类中已经存在的函数,子类中再次进行定义,在子类中重写的函数优先级高于父类中原始的函数)
|                       |           |           |        语法：父类中的函数(){新语句...}
|                       |           |           |        
|                       |           |           |------+
|                       |           |                  |
|                       |           |                  b.重写构造函数：重写构造函数时,构造函数的第一行代码必须为super()
|                       |           |                                 在方法中可以使用super来引用父类的方法：super.父类中方法
|                       |           |                    语法：class 子类名 extends 父类名{
|                       |           |                               constructor(变量1){
|                       |           |                                   super(变量1)    //调用父类的构造函数,确保父类的变量可以正常创建
|                       |           |                                   语句...
|                       |           |                               }
|                       |           |                         }
|                       |           |
|                       |           |------+
|                       |           |      |
|                       |           |      4.通过继承可以减少重复的代码,并且可以在不修改一个类的前提下对其进行扩展
|                       |           |
|                       |           |------+
|                       |                  |
|                       |                  5.OCP(开闭原则)：程序应该对修改关闭,对扩展开放
|                       |
|                       |------+
|                              |
|                              多  态(灵活性)
|                                   |
|                                   |------+
|                                   |      |
|                                   |      1.在js中不会检查参数的类型,所以这就意味着任何数据都可以作为参数传递
|                                   |
|                                   |------+
|                                   |      |
|                                   |      2.要调用某个函数,无需指定的类型,只要对象满足某些条件即可
|                                   |
|                                   |------+
|                                          |
|                                          3.多态为我们提供了灵活性
|                       
|------+
|      |
|      类的简介
|           |
|           |------+
|           |      |
|           |      产生背景：
|           |      直接使用Objec创建对象的问题:
|           |         1.无法区分出不同类型的对象
|           |         2.不方便批量创建对象
|           |      解决措施：js中可以通过类(class)来解决这个问题：通过类来创建一个对象
|           |
|           |------+
|           |      |
|           |      类的作用
|           |           |
|           |           |------+
|           |           |      |
|           |           |      1.类是对象模板,可以将对象中的属性和方法直接定义在类中,定义后就可以直接通过类来创建对象
|           |           |
|           |           |------+
|           |           |      |
|           |           |      2.通过同一个类创建的对象,我们称之为同类对象,可以使用instanceOf来检查一个对象是否由某个类创建(变量名 instanceOf 类名)
|           |           |
|           |           |------+
|           |                  |
|           |                  3.如果某个对象是某个类所创建,则我们称该对象是这个类的实例
|           |               
|           |------+
|           |      |
|           |      通过类创建对象
|           |           |
|           |           |------+
|           |                  |
|           |                  语法：变量 = new 类名()    //通过赋值的方法,将创建的类的地址传递给变量
|           |
|           |------+
|           |      |
|           |      类的说明
|           |           |
|           |           |------+
|           |           |      |
|           |           |      1.类的代码块,默认就是严格模式,不能写不符合类代码块内语法的内容
|           |           |
|           |           |------+
|           |           |      |
|           |           |      2.类代码块中的属性：类中的实例属性只能通过实例访问
|           |           |
|           |           |------+
|           |           |      |
|           |           |      3.属性值 = 函数/箭头函数     //添加方法的一种方式,通过类创建的实例来调用该方法
|           |           |
|           |           |------+
|           |           |      |
|           |           |      4.函数名(){语句...}           //在类中添加实例方法,实例方法中this就是当前实例,通过类创建的实例来调用该方法
|           |           |
|           |           |------+
|           |                  |   
|           |                  5.static 函数名(){语句...}  //在类中添加静态方法(类方法),通过类本身来调用：类名.静态方法
|           |                    
|           |------+
|           |      |
|           |      类中可以使用的关键字
|           |           |
|           |           |------+
|           |           |      |
|           |           |      static：表示属性/方法是一个静态的属性/方法
|           |           |              类中的静态属性只能通过类本身去访问,不能通过类的实例去访问：类名.静态属性/静态方法
|           |           |
|           |           |------+
|           |                  |
|           |                  new：创建一个类的实例
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      参考网站：https://developer.mozilla.org
|           |                       |
|           |                       |------+
|           |                              |
|           |                              当使用new去调用一个函数时,这个函数会作为构造函数调用
|           |                                   1.创建一个普通的js对象(Object对象{})
|           |                                   2.将构造函数的prototype属性设置为新对象的原型
|           |                                   3.使用实参来执行构造函数,并将新对象设置为函数中的this
|           |                                   4.如果构造函数返回的是一个非原始值,则该值会作为new运算的返回值返回
|           |                                           如果构造函数的返回值是一个原始值或者没有指定返回值,则新的对象会作为返回值返回,通常不会为构造函数指定返回值
|           |------+
|           |      |
|           |      语法：(类名使用大驼峰命名法,即首字母大写,其余字母小写)
|           |        class 类名{
|           |            //添加属性
|           |              属性名1: 属性值1
|           |              属性名2: 属性值2
|           |              属性名3: 属性值3
|           |              ...
|           |            //添加方法
|           |              函数名1(){
|           |                语句...
|           |              }
|           |              函数名2(){
|           |                语句...
|           |              }
|           |              函数名3(){
|           |                语句...
|           |              }
|           |              ...    
|           |        }
|           |
|           |------+
|           |      |
|           |      类中构造函数
|           |           |
|           |           |------+
|           |           |      |
|           |           |      说明：
|           |           |           1.在类中可以添加一个特殊的方法(类中定义好的函数)：constructor(这个函数是定义好的,不可以由用户自定义名称)
|           |           |           2.该方法我们称为构造函数(构造方法)
|           |           |           3.构造函数会在我们调用类创建对象时执行(在使用类创建实例对象时,constructor函数已经执行了)
|           |           |           4.在构造函数中,this表示当前所创建的实例
|           |           |
|           |           |------+
|           |           |      |
|           |           |      作用：可以动态地给实例/类中的属性名进行赋值
|           |           |
|           |           |------+
|           |                  |
|           |                  语法：
|           |                    class 类名{
|           |                       constructor(变量1,变量2,变量3,……){
|           |                           this.属性名1 = 变量1  
|           |                           this.属性名2 = 变量2   
|           |                           this.属性名3 = 变量3   
|           |                           ...                                    
|           |                       }
|           |                    }
|           |
|           |------+
|                  |
|                  旧  类
|                       |
|                       |------+
|                       |      |
|                       |      早期js中,直接通过函数来定义类
|                       |           1.一个函数如果直接调用 xxx()那么这个函数就是一个普通函数
|                       |           2.一个函数如果通过new调用, new xxx() 那么这个函数就是一个构造函数,可以用来创建一个对象
|                       |             function 函数名(){语句...}
|                       |             普通函数：函数名()         //调用一个函数
|                       |             构造函数：new 函数名()    //创建一个类
|                       |
|                       |------+
|                       |      |
|                       |      在构造函数中,this表示新建的实例：this.属性名,可以直接进行传参;这样就不需要依赖constructor(){}函数了
|                       |
|                       |------+
|                       |      |
|                       |      向原型中添加属性(方法)：类名.prototype.函数名 = function(){语句...}      
|                       |          添加静态属性(方法)：类名.staticProperty = "xxx"
|                       |                            类名.staticMethod = function(){语句...}
|                       |
|                       |------+
|                              |
|                              将旧类需要的代码都放在一个立即执行函数中,返回一个类名,用一个变量去接受(闭包)
|                                   var 类名 = (function(){
|                                                   function 类名(){
|                                                       语句...
|                                                   }
|                                                   return 类名
|                                              })()
|
|------+
|      |
|      数  组
|           |
|           |------+
|           |      |
|           |      简  介
|           |           |
|           |           |------+
|           |           |      |
|           |           |      数组(Array)
|           |           |          1.数组也是一种复合数据类型,在数组可以存储多个不同类型的数据(任何类型的值都可以成为数组中的元素)：[数字,字符串,布尔值,对象(包括数组),函数]
|           |           |          2.数组中存储的是有序的数据(按照数组下标的顺序进行存储),数组中的每个数据都有一个唯一的索引,可以通过索引来操作获取数据
|           |           |------+
|           |           |      |
|           |           |      一维数组：数组存储非数组元素          [] -> [] -> []
|           |           |
|           |           |------+
|           |           |      |
|           |           |      二维数组：数组存储的元素仍然是数组    [ [] [] []] -> [ [] [] []] -> [ [] [] []]
|           |           |
|           |           |------+
|           |           |      |
|           |           |      三维数组：数组存储的元素仍然是数组,数组中的数组存储的元素仍然是数组    [ [ [] [] [] ] [ [] [] [] ] [ [] [] [] ] [ [] [] [] ] ] -> [ [ [] [] [] ] [ [] [] [] ] [ [] [] [] ] [ [] [] [] ] ] -> [ [ [] [] [] ] [ [] [] [] ] [ [] [] [] ] [ [] [] [] ] ]
|           |           |
|           |           |------+
|           |                  |
|           |                  索引(index)：一组大于0的整数,从0开始
|           |                      使用数组时,应避免非连续数组,因为它的性能不好
|           |------+
|           |      |
|           |      创建数组(创建数组时,尽量要确保数组中存储的数据类型是相同的)
|           |           |
|           |           |------+
|           |           |      |
|           |           |      通过Arry()来创建数组
|           |           |           语法：  实例名 = new Arry() 
|           |           |
|           |           |------+
|           |                  |
|           |                  创建数组字面量
|           |                       语法：数组名 = []   //数组字面量
|           |
|           |------+
|           |      |
|           |      数组中添加元素
|           |           语法：数组[索引] = 元素
|           |
|           |------+
|           |      |
|           |      读取数组中的元素
|           |           语法：数组[索引]    
|           |           如果读取了一个不存在的元素,不会报错而是返回undefined   
|           |
|           |------+
|           |      |
|           |      length方法：用来获取数组长度,获取的实际值就是数组的最大索引 + 1
|           |           向数组最后添加元素：数组[数组.length] = 元素    
|           |           length是可以修改的：数组.length = 长度 
|           |                   1.改大会增大数组空间
|           |                   2.改小会删除多余元素
|           |
|           |------+
|           |      |
|           |      数组的遍历
|           |           |
|           |           |------+
|           |           |      |           
|           |           |      作用：获取到数组中的每一个元素
|           |           |
|           |           |------+
|           |                  |
|           |                  for-of语句
|           |                        |
|           |                        |------+
|           |                        |      |
|           |                        |      作用：可以用来遍历可迭代对象
|           |                        |              可迭代对象：可以反复读取
|           |                        |
|           |                        |------+
|           |                        |      |
|           |                        |      语法：
|           |                        |         for(变量 of 可迭代对象){
|           |                        |              语句...
|           |                        |         }
|           |                        |
|           |                        |------+
|           |                               |
|           |                               执行流程：for-of的循环体会执行多次,数组中有几个元素就会执行几次
|           |                                        每次执行时,都会将一个元素赋值给变量
|           |
|           |------+
|           |      |
|           |      数组的复制
|           |           |
|           |           |------+
|           |           |      |
|           |           |      存储方式：变量 -[存储]-> 数组内存地址 -[存储]-> 数组元素地址   
|           |           |   
|           |           |------+
|           |           |      |
|           |           |      定义：复制一个对象必须产生新的对象
|           |           |
|           |           |------+
|           |                  |
|           |                  使用slice复制：调用slice方法时,会产生一个新的对象,产生的新对象是一个新的数组,但是这个数组内部存储的地址仍然是初始数组元素地址
|           |                                 修改新数组中的元素,对旧数组仍然有影响
|           |
|           |------+
|           |      |
|           |      数组的去重
|           |           |
|           |           |------+
|           |           |      |
|           |           |      算法思路
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      1.分别获取数组中的元素
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      2.获取当前值后边的所有值
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      3.判断两个数是否相等
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  4.出现了重复元素,删除后边的元素
|           |           |
|           |           |------+
|           |                  |
|           |                  算法漏洞
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      当arry[i]和arry[j]相同时,它会自动的删除j位置的元素,然后j+1位置的元素会变成j位置的元素,
|           |                       |      而j位置已经比较过了,不会重复比较,所以会出现漏比较的情况
|           |                       |
|           |                       |------+
|           |                              |
|           |                              解决办法：当删除一个元素后,需要将该位置的元素再比较一遍
|           |------+
|           |      |
|           |      浅拷贝(shallow copy)：1.通常对对象的拷贝都是浅拷贝
|           |                           2.只对数组的浅层进行复制,并没有对下一层(数组元素层)进行复制
|           |                           3.如果对象中存储的数据是原始值,那么拷贝的深浅不重要
|           |                           4.浅拷贝只会对对象本身进行赋值,不会复制对象中的属性(或元素)
|           |
|           |------+
|           |      |
|           |      深拷贝(deep copy)：深拷贝指不仅复制对象本身,还复制对象中的属性和元素
|           |             拷贝方法：structuredClone()   //专门用来深拷贝的方法
|           |                 语法：新数组.strycryredClone(原始数组)
|           |             深拷贝性能较差,不建议使用
|           |
|           |------+
|           |      |
|           |      展开运算符：...
|           |          可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
|           |          通过它可以对数组进行浅复制
|           |      语法：新数组[(新值),...旧数组,(新值)]
|           |           |
|           |           |------+
|           |                  |
|           |                  对象的复制
|           |                       |
|           |                       |------+
|           |                              |
|           |                              Object.assign(目标对象,被复制的对象)
|           |                                将被复制对象中的属性复制到目标对象里,并将目标对象返回
|           |                              也可以用展开运算符对对象进行复制：目标对象 = {...被复制的对象}
|           |                                 同一类型元素,复制时,靠后的元素会覆盖靠前的元素
|           |       
|           |------+
|                  |
|                  数组方法
|                       |
|                       |------+
|                              |
|                              方法类型
|                                   |
|                                   |------+
|                                   |      |
|                                   |      破坏性方法：破坏性方法会对原数组造成影响
|                                   |           |
|                                   |           |------+
|                                   |           |      |
|                                   |           |      push()：向数组的末尾添加一个或多个元素,并返回新数组的长度
|                                   |           |      语法：数组名.push(元素1,元素2,...)
|                                   |           |
|                                   |           |------+
|                                   |           |      |
|                                   |           |      pop()：删除并返回数组的最后一个元素
|                                   |           |      语法：数组名.pop()
|                                   |           |
|                                   |           |------+
|                                   |           |      |
|                                   |           |      unshift()：向数组的开头添加一个或多个元素,并返回新的长度
|                                   |           |      语法：数组名.unshift(元素1,元素2,元素3,...)
|                                   |           |    
|                                   |           |------+
|                                   |           |      |
|                                   |           |      shift()：删除并返回数组的第一个元素
|                                   |           |      语法：数组名.shift()
|                                   |           |        
|                                   |           |------+
|                                   |           |      |
|                                   |           |      splice()：可以删除、替换数组中的元素
|                                   |           |        参数: 1.起始位置
|                                   |           |              2.删除的数量
|                                   |           |              3.要替换的元素(删除后一个元素后,从删除元素的位置开始去插入元素)
|                                   |           |        返回值:返回被删除的元素
|                                   |           |        
|                                   |           |------+
|                                   |           |      |
|                                   |           |      reverse()：反转数组
|                                   |           |      语法：数组名.reverse()
|                                   |           |
|                                   |           |------+
|                                   |           |      |
|                                   |           |      sort()：用来对数组进行排序(会改变原数组)
|                                   |           |      语法：数组名.sort()
|                                   |           |      sort默认会将数组升序排列
|                                   |           |      sort默认按照Unicode编码进行排序,所以如果直接通过sort对数字进行排序,可能会得到一个不正确的结果
|                                   |           |      参数: 
|                                   |           |      可以传递一个回调函数作为参数,通过回调函数来指定排序规则
|                                   |           |      升序排列：(a, b) => a - b
|                                   |           |      降序排列：(a, b) => b - a
|                                   |           |
|                                   |           |------+
|                                   |           |      |
|                                   |           |      forEach()：用来遍历数组
|                                   |           |      需要一个回调函数作为参数,这个回调函数会被调用多次
|                                   |           |      数组中的元素个数,决定了回调函数被调用的次数
|                                   |           |      每次调用,都会将数组中的数据作为参数传递
|                                   |           |      回调函数中有三个参数:
|                                   |           |      1.element 当前的元素
|                                   |           |      2.index 当前元素的索引
|                                   |           |      3.array 被遍历的数组
|                                   |           |      语法：数组名.forEach(([element],[index],[array]) => {语句...})
|                                   |------+
|                                          |
|                                          非破坏性方法：非破坏性方法,不会影响原数组,而是返回一个新的数组
|                                               |
|                                               |------+
|                                               |      |
|                                               |      Array.isArry()：用来检查一个对象是否是数组
|                                               |
|                                               |------+
|                                               |      |
|                                               |      at()：可以通过索引获取数组中的指定元素
|                                               |            at可以接受负索引作为参数,表示从右往左开始;正索引表示从左往右开始   语法：数组.at(索引值)
|                                               |
|                                               |------+
|                                               |      |
|                                               |      indexOf()：获取元素在数组中第一次出现的索引
|                                               |           参数：1.要查询的元素
|                                               |                 2.查询的起始位置
|                                               |
|                                               |------+
|                                               |      |
|                                               |      lastIndexOf()：获取元素在数组最后一次出现的位置
|                                               |            返回值：1.找到了则返回元素的索引
|                                               |                   2.没有找到返回-1
|                                               |
|                                               |------+
|                                               |      |
|                                               |      join()：将一个数组中的元素连接为一个字符串   
|                                               |          参数：指定一个字符串作为连接符,默认逗号作为连接符
|                                               |               自定义连接符：数组名.join("连接符")
|                                               |
|                                               |------+
|                                               |      |
|                                               |      slice()：用来截取数组
|                                               |          参数：1.截取的起始位置(数组下标作为参数,包括该位置)  
|                                               |               2.截取的结束位置(不包括该位置)
|                                               |            第二个参数可以忽略不写,如果省略则会一直截取到最后 一个元素
|                                               |            索引可以是负值(负值表示从后往前数)
|                                               |            如果将两个参数全部省略,则可以对数组进行浅拷贝(浅复制)            
|                                               |          语法：数组名.slice(起始下标,结束下标)
|                                               |
|                                               |------+
|                                               |      |
|                                               |      concat()：用来连接两个或多个数组     语法：数组1.concat(数组2,数组3,……)   
|                                               |
|                                               |------+
|                                               |      |
|                                               |      filter()：将数组中符合条件的元素保存到一个新数组中返回
|                                               |      需要一个回调函数作为参数,会为每一个元素去调用回调函数,并根据返回值来决定是否将元素添加到新数组中
|                                               |      回调函数中有三个参数:
|                                               |      1.element 当前的元素
|                                               |      2.index 当前元素的索引
|                                               |      3.array 被遍历的数组
|                                               |      语法：数组名.filter((element,index,array) => {语句...))
|                                               |
|                                               |------+
|                                               |      |
|                                               |      map()： 根据当前数组生成一个新数组
|                                               |      需要一个回调函数作为参数,回调函数的返回值会成为新数组中的元素
|                                               |      回调函数中有三个参数:
|                                               |      1.element 当前的元素
|                                               |      2.index 当前元素的索引
|                                               |      3.array 被遍历的数组
|                                               |      语法：数组名.((element,index,array) => {语句...))
|                                               |
|                                               |------+
|                                                      |
|                                                      redece()：可以用来将一个数组中的所有元素整合为一个值
|                                                      参数：1.回调函数,通过回调函数来指定合并的规则
|                                                           2.可选参数,初始值  
|
|------+
|      内建对象
|           |
|           |------+
|           |      |
|           |      解构赋值
|           |           |
|           |           |------+
|           |           |      |
|           |           |      说明：分解一个对象结构,然后赋值给别人,对自身结构不产生影响(将一个对象内的属性,赋值给一个新的对象)
|           |           |     
|           |           |------+
|           |           |      |
|           |           |      解构数组
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      说明：将数组内的值分配给几个变量
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  语法：关键字声明 [变量1,变量2,变量3,...] = [值1,值2,值3,...](数组)   //将值1赋值给变量1,值2赋值给变量2,值3赋值给变量3,...;声明同时解构
|           |           |                        关键字声明 [变量1,变量2,...变量3] = [值1,值2,值3,...]         //解构数组时,可以使用...来设置获取多余的元素,将多余的元素存储到变量3中
|           |           |                        
|           |           |------+
|           |           |      |
|           |           |      解构返回值
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      说明：将返回的值分配给几个变量
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  语法：function 函数(){
|           |           |                             语句...
|           |           |                             return [值1,值2,值3,...]
|           |           |                        }
|           |           |                        关键字声明 [变量1,变量2,变量3,...] = 函数()
|           |           |
|           |           |------+
|           |           |      |
|           |           |      交换变量
|           |           |           |
|           |           |           |------+
|           |           |           |      |
|           |           |           |      通过解构赋值来交换两个变量的值
|           |           |           |
|           |           |           |------+
|           |           |                  |
|           |           |                  语法：关键字声明 [变量1,变量2] = [变量2,变量1]    //变量在等号左边表示一个变量,在等号右边的时候表示的是自己的值
|           |           |
|           |           |------+
|           |                  |
|           |                  对象的解构
|           |                       |
|           |                       |------+
|           |                       |      |
|           |                       |      说明：将对象中的属性值分别赋值给变量
|           |                       |           对象中没有属性会返回undefined
|           |                       |
|           |                       |------+
|           |                              |
|           |                              语法： 关键字声明 {变量1,变量2,变量3,...} = 对象名        //格式1
|           |                                    /*格式2
|           |                                    关键字声明 变量1,变量2,变量3,...
|           |                                    ({变量1,变量2,变量3,...}) = 对象名          //此处使用括号是因为在js语言中,{}表示代码块,使用({})表示这不是一个代码块
|           |                                    */
|           |                                    /*
|           |                                    变量1 = 对象名.属性值1
|           |                                    变量2 = 对象名.属性值2 
|           |                                    变量3 = 对象名.属性值3
|           |                                    ...
|           |                                    */
|           |                                    /*通过冒号指定别名
|           |                                    关键字声明 {属性名1:变量1,属性名2:变量2,属性名3:变量3,...} = 对象名         //将对象中的属性1赋值给变量1,属性2赋值给变量2,属性3赋值给变量3,...
|           |                                    {属性名1:变量1,属性名2:变量2,属性名3:变量3,属性名4:变量4="值"...} = 对象名  //可以指定不存在的别名,如果存在,就赋值;不存在就使用默认值
|           |                                    */
|           |------+
|           |      |
|           |      Map对象
|           |            |
|           |            |------+
|           |            |      |
|           |            |      作用：用来存储键值对结构的数据(key-value)
|           |            |            键值对结构：key:value
|           |            |            Object中存储的数据就可以认为是一种键值对结构
|           |            |
|           |            |------+
|           |            |      |
|           |            |      Map与Object的区别：
|           |            |          1.Object中国的属性名只能是字符串或符号,如果传递了一个其他类型的属性名,JS解释器会自动将其转换为字符串
|           |            |          2.Map中任何类型的值都可以为数据的key
|           |            |          关键字声明 map = new Map()    //创建一个Map
|           |            |          map.set(key[any],value[any])    //任何数据类型都可以作为属性名
|           |            |
|           |            |------+
|           |            |      |
|           |            |      属性和方法
|           |            |           |
|           |            |           |------+
|           |            |           |      |
|           |            |           |      map.size()    //获取map中键值对的数量
|           |            |           |
|           |            |           |------+
|           |            |           |      |
|           |            |           |      map.set(key，valeu)    //向map中添加键值对
|           |            |           |
|           |            |           |------+
|           |            |           |      |
|           |            |           |      map.get(key)    //根据key获取值
|           |            |           |
|           |            |           |------+
|           |            |           |      |
|           |            |           |      map.delete(key)    //删除指定数据
|           |            |           |
|           |            |           |------+
|           |            |           |      |
|           |            |           |      map.has(key)    //检查map中是否包含指定的键    有:返回true 没有:返回false
|           |            |           |
|           |            |           |------+
|           |            |           |      |
|           |            |           |      map.clear(key，valeu)    //清空map(删除map中的全部键值对)
